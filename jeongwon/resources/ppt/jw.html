<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js – The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/sky.css" id="theme">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
			
				<section>
					<h1>The Arc</h1><br/>
					<h3>대구 강정보 디아크</h3><br/>
					<small><a href="http://thearc.co.kr" target="_blank">www.thearc.co.kr</a><br><br>Create by <a href="http://github.com/kofelo123" target="_blank">허정원</a></small>
					
					<aside class="notes">
						발표시작하겠습니다.
저는 대구 강정보에 있는 디아크라는 문화관광지에 대한 홈페이지를 만들었습니다.
아래에 보이는 url로 들어오시면 들어오실 수 있습니다.
						</aside>
				</section>
				
				<section>
					<section>
						<h1>개발환경</h1>
							<aside class="notes">
		개발환경에 대해 설명드리겠습니다				
	</aside>
					</section>
					<section>
						<h2>작업환경</h2>
							<div class="fragment" style="margin-left:250px;">
								<img src="presentation/sts.PNG" style="height:100px;width:100px;display:block"/>
								<img src="presentation/mysql.PNG" style="height:100px;width:100px;display:block"/>
								<img src="presentation/maven.PNG" style="height:100px;width:100px;display:block"/>
							
								<div class="fragment2" style="position:absolute;top:120px;right:250px;">
									<img src="presentation/bootstrap.PNG" style="height:100px;width:100px;display:block"/>
									<img src="presentation/tomcat.PNG" style="height:100px;width:100px;display:block"/>
									<img src="presentation/github.PNG" style="height:100px;width:100px;display:block"/>
								</div>		
							</div>		
							
								<aside class="notes">
			우선 로컬의 작업환경에서 STS Mysql Maven , 프론트쪽 디자인에 부트스트랩과 그 템플릿을 사용했고
아파치 톰캣, 버전관리를 위해 깃허브를 사용했습니다.			
	</aside>									
					</section>
					<section>
						<h2>서버환경</h2><br>
							<div class="fragment" style="margin-left:250px;">
								<img src="presentation/aws.PNG" style="height:100px;width:100px;display:block"/>
								<img src="presentation/ubuntu.PNG" style="height:100px;width:100px;display:block"/>
								<img src="presentation/gabia.PNG" style="height:100px;width:100px;display:block"/>
							
								<div class="fragment" style="position:absolute;top:190px;right:250px;">
									<img src="presentation/filezila.PNG" style="height:100px;width:100px;display:block"/>
									<img src="presentation/xshell.PNG" style="height:100px;width:100px;display:block"/>
								</div>		
							</div>	
							
								<aside class="notes">
			서버쪽 환경으로는
AWS에서 우분투를 한대 임대받아서 클라우드 호스팅했고, 그 ip와 가비아에서 구매한 도메인 thearc.co.kr에 연결했습니다.
로컬에서 작업후에 war배포파일을 filezila를 통해서 우분투에 배포하였고, xshell을 이용해서 터미널로 서버를 제어했습니다.			
	</aside>	
					</section>		
			
				</section>
				
				<section>
					<section>
						<h2>홈페이지 기능소개</h2>
					</section>
					<section>
						
						<h2>회원</h2><br>
						<div class="fragment">
							<ul>
								<li>로그인</li>
								<li>회원가입</li>
								<li>ID/PW찾기</li>
								<li>권한</li>
								<li>메세지함</li>
							</ul>
						</div>
						<aside class="notes">
			홈페이지 전반적인 기능에 대해 설명하겠습니다.
회원관련 기능으로는 로그인,회원가입,id/pw찾기,권한,메세지함의 기능이 있고,			
	</aside>
					</section>
					<section>
						<h2>API활용</h2><br>
						<div class="fragment">
							<ul>
								<li>구글맵API</li>
								<li>기상API</li>
								<li>도로명주소API</li>
								<li>유투브API</li>
								<li>아파치 commons mail API</li>
							</ul>
						</div>
							<aside class="notes">
					활용한 api는 구글맵,공공데이터포탈의 기상청 api,도로명주소 api,유투브api,apache commons email api를 활용했습니다.	
	</aside>
					</section>
					<section>
						<h2>게시판</h2><br>
						<div class="fragment">
							<ul>
								<li>다중게시판(종류,미니)</li>
								<li>댓글</li>
								<li>업로드</li>
								<li>에디터</li>
								<li>SNS</li>
								<li>관리자페이지</li>
							</ul>
						</div>
						<aside class="notes">
				게시판의 기능은 다중게시판, 실제 게시판 db는 하나지만 카테고리 칼럼을 둬서 
uri 경로에 따라 종류별로 분류하고,보여지는 리스트를 다르게 처리해봤습니다. 그리고 메인페이지에서 게시판 미리보기 같은것을 구현했습니다.
그리고 Ajax,Rest를 사용한 댓글,업로드 기능이 있고, 게시판에 오픈소스 에디터를 달았습니다. 그리고 sns 연동 기능이 있으며,관리자페이지를 따로 뒀습니다.		
	</aside>
					</section>
					
				</section>
				
				<section>
					<h2>DB 테이블</h2>
					<div class="fragment">
						<img src="presentation/db.PNG"/>
					</div>
					
					<aside class="notes">
			DB테이블을 보여드리겠습니다.
크게 User테이블과 Board테이블이 있고, user테이블에서는 
비밀번호 같은 경우 비밀번호를 바로저장하지 않고 sha-256 암호화해서 저장하고 로그인시에도 암호화시켜서 저장된 암호값과 비교하도록 되어있습니다.
sessionkey,sessionlimit의 경우 자동로그인 기능 체크했을때 세션의 아이디값을 쿠키로 저장하는 용도로 사용됩니다.
authority의 경우 로그인 한 사용자중에 일반회원,서포터즈(매니저),관리자 ,사용정지된계정 이렇게 권한을 나누기 위해서 만들었습니다.
message는 메세지 보내는 기능,check는 추천을 체크하는 용도로 그냥 만들었습니다.

board테이블을 보면 자식테이블로 댓글,첨부파일에 대한 테이블이 있고 board테이블에는 카테고리 칼럼이 있는데,
db테이블은 하나로 두고, 여러 종류의 게시판을 두기위한 분류를 위해서 이런 칼럼을 뒀습니다.
				
	</aside>
				</section>
				
				<section>
					<h2>홈페이지 시연</h2><br>
					<h4 style="color:blue"><a href="http://www.thearc.co.kr" target="blank">http: // www . thearc . co . kr</a></h4>
			<aside class="notes">
			홈페이지 시연을 해보겠습니다.
--
홈화면에는 풀스크린 영상을 유투브를 통해서 스트리밍으로 재생되도록 했습니다.
홈화면에서는 입장하기를 비롯해서, 관리자 페이지로 바로 접근할수 있도록 되어있습니다.
--
메인페이지에는 드롭다운 방식의 네비게이터, 우측에는 서브 메뉴바가 있고
flexslider를 통해 이미지를 전환하게 했고,
공공데이터포탈에서 기상청API로 디아크의 위치인 달성군 다사읍의 기상정보를 웹상에서 받아 원하는 데이터만 뽑아서
vo에 담은다음 컨트롤러를 거쳐서 view에다가 뿌리고,
뿌린 정보의 날씨 정보 따라서 이미지를 준것입니다.

그리고 아래에는 주요 게시판들의 최근 5개 게시물들을 미리볼수 있도록 하였습니다.
--
로그인해보겠습니다.
회원가입의 특이점은 비밀번호를 저장시에 sha-256 방식으로 암호화해서 저장한다는점, 도로명주소api를 활용한다는 점입니다.
로그인할때 로그인유지체크를 하면 세션의 아이디값을 쿠키로 저장해서 세션이 죽어도 쿠키가 남아있으면 자동로그인 될수 있도록 했습니다.
id/pw찾기를 해보겠습니다. 가입한 이메일 주소를 입력하면,SMTP 프로토콜로 인해 메일이 전송이 되고 
메일에는 아이디를 표기하고, 비밀번호 변경은 이미지를 클릭하면 아이디,비밀번호를 파라미터로 주고 변경할수있는 링크를 제공하는데
암호화되어 있기 떄문에 링크에 노출되어도 안전하며 변경후에는 이링크가 사용불가하기 때문에 안전합니다.
메세지함에서 메세지를 보낼수 있도록 했습니다.
--
다음으로는 게시판들을 보겠습니다.
...

찾아오시는길은 구글맵api를 활용해서 구현했습니다.
구글 레퍼런스에서 제공하는 예제들중에 활용할만한것을 찾아서 제가 원하는것에 맞게 수정했습니다.
출발지를 입력하면 길찾기를 할수 있도록 했고, 디아크에 대한 정보를 넣어줬습니다.
--
게시판은 일반적인 게시판이 있고, 내용은 같지만 보여지는 리스트를 다르게 해서 썸네일게시판,포토존을 구현해봤습니다.
부하를 줄이기 위해서 원본을 썸네일로 작게 만들어서 보여지도록 되어있습니다.
그리고 회원의 등급에 따라 서포터즈 게시판은 서포터즈,관리자만, 공지사항게시판은 관리자만 글을 쓸수있도록 설정했습니다.

게시글을 써보겠습니다.
mit 라이센스의 summernote 오픈소스 에디터를 적용시켰기 떄문에 이미지나 영상을 입힐수 있습니다.
파일 업로드는 서버단에서 REST방식을, 프론트쪽에서 Ajax를 통해 화면전환없이 드래그앤드롭방식으로 처리됩니다.
작성한글을 읽을때에는 추천하는기능,SNS연동,댓글 기능이 있고
댓글의 경우 업로드처럼 Ajax로 화면전환없이 처리됩니다.
--
부가기능으로 뮤직플레이어를 오픈소스로 활용했습니다.	

그리고 미흡하지만 홈페이지를 반응형웹 페이지로 모바일 디바이스에서도 사용가능하도록 구현했습니다.
부트스트랩의 그리드로 좌우폭을 디바이스에 따라 변경하거나 , 미디어쿼리를 사용해서 모바일 사이즈에서 
크기를 조절,삭제,변경하는 작업을 처리했습니다.

마지막으로 관리자 페이지에 들어가보겠습니다.
관리자페이지에는 관리자 계정만 접근할수있으며, 사용자의 목록으로부터 사용자의 권한을 변경하거나, 계정을 삭제, 사용정지 처리할수있게 구현해봤습니다.
그리고 통계 페이지를 구현했는데, 보이는 디자인은 부트스트랩의 템플릿을 사용했고,서버단에서의 쿼리를 짜서 데이터를 가져와 적용시키는것을 직접 하였습니다. 
위의그래프는 날짜별로 게시물과 댓글갯수에 대한 통계이고, 왼쪽 그래프는 주요게시판별 방문횟수,
우측에는 한주간 게시판별 작성글,댓글 통계입니다.
마지막으로 게시판관리는 주요 게시판의 글들을 관리자가 삭제할수 있도록 했습니다.
원래는 작성자만이 삭제할 수 있지만 관리자가 직접 삭제할수 있도록 하였습니다.
			
	</aside>	
				</section>
				
				<section>
					<h2><a href="#" onclick="document.getElementById('theme').setAttribute('href','css/theme/beige.css'); return false;">구현설명</a></h2><br>
					<!-- <a href="#/6"><h4>프로젝트구조</h4></a> -->
					<a href="#/6"><h4>의존주입</h4></a><br>
					<!-- <a href="#/8"><h4>AOP & 트랜잭션</h4></a> -->
					<a href="#/7"><h4>스프링 인터셉터</h4></a><br>
					<a href="#/8"><h4>Ajax&REST</h4></a>
					
					<aside class="notes">
			구현설명을 하겠습니다.
설명을 어떻게 할지 생각을 해봤는데, 스프링의 관점에서 설명을 하겠습니다.			
	</aside>
				</section>
				
			<!-- 	<section>
					<section>
					<h2>프로젝트구조</h2>
					<div class="fragment" style="position:absolute;top:-20px;left:-180px;height:750px;">
					<img src="presentation/projectstructure.PNG" />
					</div>
					<img class="fragment" src="presentation/structure2.PNG" style="margin-right:50px;"/>
					<img class="fragment" src="presentation/structure3.PNG" />
					<img class="fragment" src="presentation/structure4.PNG" />
					<aside class="notes">
			프로젝트 구조는 Spring MVC + MAVEN 구조이며
pom.xml에 사용할 라이브러리 등을 dependency로 명시해 메이븐이 라이브러리를 관리하도록 하며,
위에 자바코드소스들이 있고 아래에 매퍼 디렉터리에 mybatis xml파일들이있고 ... webapp에 resouces 폴더에 부트스트랩 css 등 웹자원들을두고
실제 jsp파일은 WEB-INF에 있는데, WEB-INF에 jsp를 둬야 브라우저에서 직접적인 접근을 못하고 controller를 통해 접근할수 있도록 할수있습니다.
spring 폴더에 스프링 관련 설정파일인 root-context와 servlet-context가 있습니다.	

dao파일이 있는 persistence layer와 service파일이 있는 bisuniess layer에서는 
인터페이스-구현클래스로 되어있는데, 관계를 느슨히하고 외부의 xml에서 원하는 구현체를 주입하기 위해서 입니다.			
	</aside>
					</section>
					
					<section>
						<h2>스프링 MVC 구조</h2>
					<img class="fragment" src="presentation/springmvc2.PNG" />
					<div class="fragment" style="position:absolute;bottom:60px;right:-20px;height:30px;width:30px;">
						<a href="#/5"><img src="presentation/turnback.PNG" /></a>
					</div>
					<aside class="notes">
		다음은 스프링 MVC구조에 대해 설명하겠습니다.
클라이언트의 요청이 들어오면 우선 FrontController인 DispatcherServlet이 받아서 핸들러매핑으로 
요청에 해당하는 컨트롤러매핑으로 전달된후,
controller와 dao사이에서 완충역할을 하는 service계층으로 전달되어서 dao로 , dao에서 mybatis의 xml파일로 전달되어 최종적으로 db에 접근하게됩니다. 원하는 데이터처리후 리턴타입이 있으면 역순으로 돌아와 
controller에서 model로 viewResolver에 의해 인식된 jsp에 데이터가 전달됩니다.				
	</aside>
					</section>
				</section> -->
				
				<section>
					<!-- <section>
						<h2>의존주입<span>( DI , IOC )</span></h2><br>
						<div class="fragment"><h3>응집도 & <span class="fragment highlight-red grow" >결합도</span></h3></div><br>
						<span class="fragment">new 의존클래스 x ->  </span><span class="fragment"> 종속적 x - 유지보수 강점</span><br><br>
						<span class="fragment">인터페이스</span><span class="fragment">  <--- 구체적 의존모듈 주입</span> <br><br>
						<span class="fragment">배포후 수정-> </span><span class="fragment"> .class -  xml에서 수정</span>
						<aside class="notes">
		다음은 스프링의 의존주입에 대해 설명하겠습니다.
소프트웨어의 유지보수측면에서 중시되는 높은응집도와 낮은결합도 중에 의존주입은 결합도를 낮추는 역할을 한다고 볼 수 있는데요,
자바코드상에서 new 의존클래스를 명시해주지 않음으로 인해서 종속적이지 않고 
자바코드에서 인터페이스를 타입으로 두고 외부 xml에서 구체적인 의존모듈을 주입함으로 인해서 유지보수에 강점을 가집니다.
또, 배포후에 class파일만 남게 되어 자바소스상에서 수정하기 힘든데, 의존주입을 통해 xml에서 쉽게 수정이 가능합니다.				
	</aside>
					</section> -->
					
					<section>
					<h2>의존주입 적용</h2><br>
					<h4 class="fragment" style="margin-left:-70px;">스프링빈 등록</h4>	
					<h4 class="fragment">Xml 기반 &nbsp;  vs&nbsp;&nbsp; 어노테이션기반</h4>	
					<h5 class="fragment" style="margin-left:-70px;">가변적요소    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;고정적요소</h5>	
					<aside class="notes">
		의존주입을 적용해보겠습니다.
스프링의 bean 등록은 xml기반 과 어노테이션기반으로 나뉩니다.
가변적인 요소들은 xml에 등록함으로 수정할이 용이하나, xml파일이 굉장히 복잡해지게 됩니다.

				
	</aside>
				</section>
					<section>
						<h3>xml 기반</h3><br>
						<pre><code class="hljs" data-trim contenteditable>
						<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
							<property name="driverClassName" value="net.sf.log4jdbc.sql.jdbcapi.DriverSpy"></property>
							<property name="url" value="jdbc:log4jdbc:mysql://127.0.0.1/thearc"></property>
							<property name="username" value="thearc"></property>
							<property name="password" value="thearc"></property>
						</bean>
						
						<bean id="ipAddress" class="java.lang.String">
							<constructor-arg value="localhost"></constructor-arg>
						</bean>
						
						<beans:bean id="uploadPath" class="java.lang.String">
							<beans:constructor-arg value="C:\\zzz\\upload">
							</beans:constructor-arg>
						</beans:bean>
					</code></pre>
					<aside class="notes">
			그리고 xml기반 처리의 경우 
xml에서 직접 빈을 명시해서 등록하게되고 이런 빈들 같은 경우는 로컬작업후 서버에 배포했을떄 설정값이 달라져야 하는데
배포후에 xml을 쉽게 수정할수 있게됩니다.				
	</aside>
					</section>
				
					<section>
						<h2>어노테이션 기반</h2><br>
						<pre><code class="hljs" data-trim contenteditable>
							@Controller
							public class SearchBoardController {
							
							@Repository
							public class MessageDAOImpl implements MessageDAO { ...
							
							@Service
							public class AdminServiceImpl implements AdminService {
							
							(root-context.xml , servlet-context.xml)
							<context:component-scan base-package="com.thearc.controller" />
							<context:component-scan base-package="com.thearc.persistence"/>
							<context:component-scan base-package="com.thearc.service"/>
	 						
						</code></pre>
						<aside class="notes">
			그래서 변하지 않는 요소들은 클래스위에 어노테이션으로 @Controller,@Repository,@Service와 같이 등록해두고
스프링 설정파일에서 component-scan으로 base package를 설정해주면 해당경로에 있는 어노테이션된 클래스들을
자동으로 스프링 bean 등록시켜주게 되어있습니다.
		
	</aside>
					</section>
					<section>
						<h2>주입</h2><br>
						<pre><code class="hljs" data-trim contenteditable>
							public class SearchBoardController {
							 @Inject
							 private BoardService service; //인터페이스타입
							 
							 service.listSearchCriteria(cri,"free")
							 
						   public class BoardServiceImpl implements BoardService {
							@Inject
							private BoardDAO dao; //인터페이스타입
							
							dao.create(board);
							
						public class BoardDAOImpl implements BoardDAO {
						  @Inject
 						  private SqlSession session;
 						  
 						  session.insert(namespace + ".create", vo);
						</code></pre>
						<div class="fragment" style="position:absolute;bottom:60px;right:-20px;height:30px;width:30px;">
						<a href="#/5"><img src="presentation/turnback.PNG" /></a>
					</div>
						<aside class="notes">
		그리고 스프링컨테이너에 등록된 빈을 실제로 주입하는것에 대해 설명하겠습니다.
등록된 스프링 빈은 자바소스상에서 @Inject,@Autowired,@Resource 와 같은 어노테이션으로 주입이되며
인스턴스변수,메소드,생성자 등에 주입가능합니다.
자바소스상에서 타입을 인터페이스로 두기떄문에 xml에서 원하는 모듈을 변경해도 자바소스상에서는 아무런 수정할 필요가 없어지므로 유지보수에 강점을 지니게 되며,종속적이지 않은,결합도가 느슨한 코드가 됩니다.				
	</aside>
					</section>
				</section>
				
				<!-- <section>
					<section>
						<h3>AOP</h3>
						<div><h3 class="fragment highlight-red grow">응집도 <span class="fragment" style="color:black;"> & 결합도</span></h3></div>
						<img class="fragment" src="presentation/aop.PNG"/>
					<aside class="notes">
		이제 AspectOfPrograming에 대해 설명하겠습니다.
사실 저는 AOP보다 스프링 인터셉터를 썻지만 간단하게 언급하고 넘기겠습니다.
앞서 DI가 결합도에 관한것이었다면, AOP는 응집도에 관한것입니다.
파란 부분이 주목적인 핵심관심사가 되겠고,
가로로 된끈들은 핵심관심사를 하는데 있어 부가적으로 따르는 것들이며 횡단 관심사라고 합니다.
문제는 이 횡단관심사들이 반복되며, 모듈안에서 복잡하여 엮여 있음으로 인해서 비효율적인 코드가 되는데
이런 관심사가 다른 횡단관심사를 분리하는 SOC가 AOP입니다.
분리해서 관리하며 사전,사후,모든위 등에 언제 처리할지 명시해서 처리하도록 합니다.				
	</aside>
					</section>
					
					<section>
					<h2>트랜잭션 적용</h2><br>
					<pre class="fragment"><code class="hljs" data-trim contenteditable>
						<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
							<property name="dataSource" ref="dataSource"></property>
						</bean>
					
						@Transactional
						@Override
						public void remove(Integer bno) throws Exception {
							dao.deleteAttach(bno);
							dao.delete(bno);
						}
						
						@Transactional(isolation = Isolation.READ_COMMITTED)///격리레벨-커밋된  데이터에 대한 읽기허용 ->업데이트중인,커밋되지 않은 데이터에 접근불가,읽는 유저는 커밋이전만 볼수있다.
						@Override
						public BoardVO read(Integer bno) throws Exception {
							dao.updateViewCnt(bno);
							return dao.read(bno);
						}
					</code></pre>
					<div class="fragment" style="position:absolute;bottom:60px;right:-20px;height:30px;width:30px;">
						<a href="#/5"><img src="presentation/turnback.PNG" /></a>
					</div>
						<aside class="notes">
		다음은 스프링 트랜잭션의 적용입니다.

(트랜잭션의 원칙인 ACID중 원자성)
트랜잭션은 두개이상의 작업을 하나의 단위로 처리하기 위해서 사용합니다. 둘다 성공해야 성공처리를 합니다.
트랜잭션 매니저를 빈으로 등록하고 사용할 메소드위에 트랜잭션 어노테이션을 주면 됩니다.
그리고 옵션으로 여러가지를 줄수있는데 위의 경우 완전히 커밋되기전에 데이터에 접근을 부가하도록 하는것입니다.				
	</aside>
	
				</section>
				</section> -->
				
				<section>
					<!-- <section>
						<h2>스프링 인터셉터</h2>
						<h4 class="fragment">서블릿필터 vs 스프링 인터셉터</h4>
						<img class="fragment" src="presentation/interceptor.PNG"/>
						<aside class="notes">
			다음은 스프링 인터셉터에 대해 설명하겠습니다.
인터셉터는 특정 매핑을 가로챈다는 점에서
인터셉터는 서블릿의 필터와 유사한 개념이나, 좀더 스프링 context에 접근이 용이하다는 차이점이 있습니다.			
	</aside>
					</section> -->
					<section>
						<h2>인터셉터</h2><br>
						<h4 class="fragment">사전,사후 처리</h4>
						<h4 class="fragment"><span class="fragment highlight-blue">인터셉터 메소드</span></h4>
						<ul class="fragment">
							<li>preHandle()</li>
							<li>postHandle()</li>
							<li>afterCompletion()</li>
						</ul>
						
					</section>
					<section>
						<h2>인터셉터 적용</h2>
						<pre class="fragment"><code class="hljs" data-trim contenteditable>
							 //servlet-context.xml
							 <beans:bean id="loginInterceptor" class="com.thearc.interceptor.LoginInterceptor"></beans:bean>
							   
							   <interceptors>
								  <interceptor>
							         <mapping path="/user/loginPost" />
							         <beans:ref bean="loginInterceptor" />
							       </interceptor>
						        </interceptors>	
							 
							 //LoginInterceptor
							 @Override
 							 public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
							 	 HttpSession session = request.getSession();
   								 if (session.getAttribute(LOGIN) != null) {
     							 	logger.info("clear login data before");
     							 session.removeAttribute(LOGIN);
    							}
						    	return true;
  							}
  							
  							
						  @Override
 						 public void postHandle(HttpServletRequest request,HttpServletResponse response, Object handler,ModelAndView modelAndView) throws Exception {
    						
    						HttpSession session = request.getSession();
						    ModelMap modelMap = modelAndView.getModelMap();  
   						    Object userVO = modelMap.get("userVO");
   						    
   						    if (userVO != null) {
    						  logger.info("new login success");
   						   	  System.out.println(userVO);
   						      session.setAttribute(LOGIN, userVO);
						    if(request.getParameter("useCookie") != null) {
						        logger.info("remember me................");
    						    Cookie loginCookie = new Cookie("loginCookie", session.getId());
    						    loginCookie.setPath("/");
    						    loginCookie.setMaxAge(60 * 60 * 24 * 7);
  						        response.addCookie(loginCookie);
   						   }
						      Object dest = session.getAttribute("dest");
  						      System.out.println("destTest:"+dest);///원래 가려고 했던 경로 (AuthInterceptoer로 부터 세션저장됨.)
 						      response.sendRedirect(dest != null ? (String)dest : "/");
 						   }
 						 }
						</code></pre>
						<a class="fragment" href="/user/login" target="_blank"><img src="presentation/link.PNG" style="height:25px;float:right;"/></a>
						<aside class="notes">
		인터셉터를 적용해보겠습니다.
우선 핸들러인터셉터어댑터 클래스를 상속받은 클래스를 빈등록시켜주고 
원하는 매핑을 설정하면 스프링 인터셉터가 가로채어 전후처리를 하게됩니다.
loginPOst,즉 로그인버튼을 눌렀을때 전처리로 이미있는 세션이 있다면 지우도록하고
컨트롤러에서 입력한 사용자,pw에 해당하는 정보를 가져온후 
후처리로 세션에 넣어주게되고, 만약 로그인유지를 눌렀을때는 세션의 아이디값에 해당하는 값을
새로 생성된일주일짜리 쿠키에 담게됩니다.				
	</aside>
					</section>
					
					<section>
						<h2>인터셉터적용2</h2>
						<pre class="fragment"><code class="hljs" data-trim contenteditable>
						//servlet-context.xml
						<beans:bean id="authInterceptor" class="com.thearc.interceptor.AuthInterceptor"></beans:bean>
						<interceptor>  <!-- 로그인해야 접근할수있게   -->
	  						  <mapping path="/sboard/register/*"/>
	   						 <mapping path="/sboard/modifyPage"/>
	   						 <mapping path="/sboard/removePage"/>
	   						 <mapping path="/sboard/mail/listmail"/>
	   						 <mapping path="/sboard/readPage/like/"/>	
	   						 <mapping path="/sboard/list/supporter"/>	
	  						  <beans:ref bean="authInterceptor"/>
				 		 </interceptor>	
						//AuthInterceptor
							@Override
  							public boolean preHandle(HttpServletRequest request,HttpServletResponse response, Object handler) throws Exception {
							    HttpSession session = request.getSession();   
    							if(session.getAttribute("login") == null){
							      logger.info("current user is not logined");
							      saveDest(request);
						      Cookie loginCookie = WebUtils.getCookie(request, "loginCookie");
						      if(loginCookie != null) { 
						        UserVO userVO = service.checkLoginBefore(loginCookie.getValue());
						        logger.info("USERVO: " + userVO);
					         if(userVO != null){
          						session.setAttribute("login", userVO);
					          authorization(request,response);
          					return true;
    						    }
   						   }
    					  response.sendRedirect("/user/login");
     					 return false;
   						 }
   						 authorization(request,response);
    				return true;
  						}  
						</code></pre>
						<a class="fragment" href="/sboard/list/free" target="_blank"><img src="presentation/link.PNG" style="height:25px;margin-left:850px;"/></a>
						<div class="fragment" style="position:absolute;bottom:60px;right:-20px;height:30px;width:30px;">
						<a href="#/5"><img src="presentation/turnback.PNG" /></a>
					</div>
					<aside class="notes">
				다음 인터셉터는 특정 uri 즉, 글쓰기,삭제 , 권한이 필요한 페이지등의 uri를 접근할때
로그인이 여부,권한을 체크하는 전처리가 되겠습니다.		
	</aside>
					</section>
				</section>
				
				<section>
					<section>
						<h1>REST & AJAX</h1>
						<aside class="notes">
		마지막으로 REST 와 AJAX에 대해 설명하겠습니다.				
	</aside>
					</section>
					<!-- <section>
						<h2> REST  </h2>
						<h4 class="fragment">URI = 데이터  &nbsp;&nbsp;&nbsp;ex)'/boards/123'</h4>
						<h4 class="fragment">@Response Body -> @Rest Controller</h4>
						<h4 class="fragment">서버단에서는 데이터만 전송(JSON)</h4>
						<h4 class="fragment">클라이언트단에서의 처리가 많을때 적합</h4>
						<h4 class="fragment">Ajax등을 처리</h4>
						<h4 class="fragment">Restful</h4>
						<aside class="notes">
		REST방식에서 URI는 데이터를 의미합니다.
메소드에 @Response Body를 명시하거나 컨트롤러에 @RESTCONTROLLER를 명시하는 방법이 있습니다.
기존의 Controller가 jsp등 뷰를 반환한다면,
RESTController는 데이터(JSON)를 반환한다고 볼수있습니다.
서버단에서는 데이터만 전송해주게 되고,클라이언트에서 Ajax로 호출하여 통신하게 됩니다.
 클라이언트에서의 처리가 많을떄 적합합니다.				
	</aside>
					</section>
					<section>
						<h2>Ajax</h2><br>
						<h4 class="fragment">비동기화 처리</h4>
						<h4 class="fragment">화면전환 없는 처리</h4>
						<h4 class="fragment">$ajax()로 서버단 로직 호출 - 데이터받음</h4>
						<h4 class="fragment">REST방식과 함께 사용, JSON데이터 사용</h4>
						<aside class="notes">
		 Ajax는 비동기화된 처리를 의미하며, 화면의 전환이 없이 처리되게 합니다.
 $ajax()로 서버단 로직을 직접 호출하여 JSON 등의 데이터를 받아 클라이언트에서 바로 처리하며
 REST방식과 함꼐 사용합니다.				
	</aside>
					</section> -->
					<section>
						<h2>적용-댓글</h2>
						<pre class="fragment"><code class="hljs" data-trim contenteditable>
							@RestController
							@RequestMapping("/replies")
							public class ReplyController {
								...
						  @RequestMapping(value = "", method = RequestMethod.POST)
						  public ResponseEntity<String> register(@RequestBody ReplyVO vo) { ///코드에서 예외대신에 Response Entity를 이용해서 사용자에게 정보를 전달한다.(HTTP상태코드+데이터 함께 전송가능)
						
						    ResponseEntity<String> entity = null;///ResponseEntity는 메세지와 http status정보를 같이 전송할수있는 스프링제공 클래스.	
						    try {
						      service.addReply(vo);
						      entity = new ResponseEntity<String>("SUCCESS", HttpStatus.OK);
						    } catch (Exception e) {
						      e.printStackTrace();
						      entity = new ResponseEntity<String>(e.getMessage(), HttpStatus.BAD_REQUEST);
						    }
						    return entity;
						  }
						...
						//readPage.jsp
						
						$("#replyAddBtn").on("click", function() {

						var replyerObj = $("#newReplyWriter");
						var replytextObj = $("#newReplyText");
						var replyer = replyerObj.val();
						var replytext = replytextObj.val();
				
						$.ajax({
							type : 'post',
							url : '/replies/',
							headers : {
								"Content-Type" : "application/json",
								"X-HTTP-Method-Override" : "POST"
							},
							dataType : 'text',
							data : JSON.stringify({
								bno : bno,
								replyer : replyer,
								replytext : replytext
							}),
							success : function(result) {
								console.log("result: " + result);
								if (result == 'SUCCESS') {
									alert("등록 되었습니다.");
									replyPage = 1;
									getPage("/replies/" + bno + "/" + replyPage);
									//replyerObj.val("");
									replytextObj.val("");
								}
							}
						});
					});
					
						</code></pre>
					
					<a class="fragment" href="/sboard/readPage/thisweek?page=1&perPageNum=10&searchType&keyword&bno=1043&uid=" target="_blank"><img src="presentation/link.PNG" style="height:25px;float:right;"/></a>
						<aside class="notes">
		실제 적용 코드를 보겠습니다.
 컨트롤러위에 RESTCONTROLLER를 명시했기때문에 해당컨트롤러는 모두 rest방식이 되게 되고,
 (우선 아래부터) 
 뷰단에서 댓글쓰기 버튼을 클릭하면 작성자와 내용의 값을 가지고 ajax호출을 하게됩니다.
 post방식으로 replies url를 호출하며,json.stringify는 json으로 데이터를 가공하는것입니다.
 그렇게 restcontroller의 메소드에 전달이되고, 
 @requestBody는 json데이터를 일반 객체데이터로 변환하는 용도입니다.
 댓글 작성 로직후에 ResponseEntity로 반환을 하는데 ResponseEntity는 데이터를 http상태코드와 함꼐 보낼수 있는 타입이라서 view를 반환하지않는 rest방식에서 쓰이게 됩니다.
 그리고 다시 view에 전달되어 성공시에 클라이언트에서 남은 처리가 이루어집니다.				
	</aside>
					</section>
					<section>
						<h2>적용-업로드</h2>
						<pre class="fragment"><code class="hljs" data-trim contenteditable>
					$(".fileDrop").on("drop", function(event){
					event.preventDefault();
					
					var files = event.originalEvent.dataTransfer.files;
					
					var file = files[0];
				
					var formData = new FormData();
					
					formData.append("file", file);	
					
					
					$.ajax({
						  url: '/uploadAjax',
						  data: formData,
						  dataType:'text',
						  processData: false,
						  contentType: false,
						  type: 'POST',
						  success: function(data){
							  
							  var fileInfo = getFileInfo(data);
							  
							  var html = template(fileInfo);
							  
							  $(".uploadedList").append(html);
						  }
						});	
				});
				//UploadController
				@Controller
				public class UploadController {
				...
				@ResponseBody
			    @RequestMapping(value ="/uploadAjax", method=RequestMethod.POST,produces = "text/plain;charset=UTF-8")
			    public ResponseEntity<String> uploadAjax(MultipartFile file)throws Exception{
			    
			    logger.info("originalName: " + file.getOriginalFilename());
			    
			    return 
			      new ResponseEntity<>(
			          UploadFileUtils.uploadFile(uploadPath, 
			                file.getOriginalFilename(), 
			                file.getBytes()), 
			          HttpStatus.CREATED);
				  }
						</code></pre>
						<a class="fragment" href="/sboard/register/free" target="_blank"><img src="presentation/link.PNG" style="height:25px;float:right;"/></a>
						<aside class="notes">
		마지막으로 업로드 로직을 보겠습니다.
 
 파일이 드래그앤 드롭이 되었을때, 원래 페이지가 넘어가는것을 막은후에 업로드할 파일의 정보를 읽은후
 formData 객체를 통해서 form과 동일한 방식으로 전송합니다.
 ajax로 서버단을 호출하는 부분이며,post방식으로 파일을 전송합니다.
 호출된 메소드는 REst컨트롤러가 아니기 때문에 Responsebody어노테이션이 붙게되고,실제 업로드 처리되는클래스의 로직을 호출하게 되고 저장된 경로와 함꼐 상태코드를 반환하게되고
 반환받은 정보를 가지고 jquery로 클라이언트쪽에 뿌리는 작업을 하게 됩니다.				
	</aside>
					</section>
				</section>
				
				<section>
					<h2>보완하고 싶은부분</h2><br>
					<h4 class="fragment">시큐리티 처리</h4>
					<h4 class="fragment">다양한 Ajax처리</h4>
					<h4 class="fragment">고급 SQL 처리</h4>
					<h4 class="fragment">구글 애널리틱스 연동</h4>
						<aside class="notes">
		설명을 마치면서
 보완하고 싶은 부분은 스프링 시큐리티에 대한적용, 좀더 다양한 ajax처리, 고급sql처리,구글 애널리틱스를 연동이 되겠습니다.
 이상입니다.				
	</aside>
				</section>
				<section>
					<h2>End</h2>
					<div class="fragment"><br>
						<a href="http://www.thearc.co.kr">www.thearc.co.kr</a><br><br>
						<h4><a href="http://www.github.com/kofelo123">허정원</a></h4>
					</div>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'convex', // none/fade/slide/convex/concave/zoom

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
